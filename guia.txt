ðŸŽ¯ GUÃA COMPLETA: PROYECTO PHILOSOPHERS

FASE 1: COMPRENSIÃ“N Y PLANIFICACIÃ“N ðŸ“š

Paso 1.1: Entender el problema conceptual
El problema clÃ¡sico: Los filÃ³sofos representan procesos que compiten por recursos compartidos (tenedores)
El deadlock: SituaciÃ³n donde todos los filÃ³sofos toman su tenedor izquierdo simultÃ¡neamente y ninguno puede tomar el derecho
Race conditions: Cuando mÃºltiples hilos acceden a datos compartidos sin sincronizaciÃ³n
Starvation: Cuando un filÃ³sofo nunca consigue ambos tenedores

Paso 1.2: Identificar los componentes principales
FilÃ³sofos (hilos/threads)
Tenedores (recursos compartidos protegidos por mutex)
Estados: thinking, eating, sleeping, died
Tiempo: timestamps, timeouts, duraciÃ³n de acciones
SincronizaciÃ³n: mutex para tenedores y para output



FASE 2: DISEÃ‘O DE LA ARQUITECTURA ðŸ—ï¸

Paso 2.1: Definir las estructuras de datos
Piensa en quÃ© informaciÃ³n necesitas almacenar para:
Cada filÃ³sofo: id, estado, Ãºltimo tiempo de comida, nÃºmero de comidas
SimulaciÃ³n global: nÃºmero de filÃ³sofos, tiempos, condiciones de parada
Tenedores: uno por filÃ³sofo con su mutex correspondiente
SincronizaciÃ³n: mutex para imprimir, variables de control

Paso 2.2: Planificar el flujo del programa
InicializaciÃ³n: parsing de argumentos, creaciÃ³n de estructuras, inicializaciÃ³n de mutex
CreaciÃ³n de hilos: un hilo por filÃ³sofo
Rutina del filÃ³sofo: bucle infinito con las acciones
Monitor: hilo que vigila la muerte y condiciones de parada
Limpieza: join de hilos, destrucciÃ³n de mutex, liberaciÃ³n de memoria



FASE 3: IMPLEMENTACIÃ“N PASO A PASO ðŸ’»

Paso 3.1: Configurar el entorno bÃ¡sico
Crear el header con todas las includes necesarias
Definir las estructuras principales
Configurar el Makefile correctamente
Crear los archivos fuente bÃ¡sicos

Paso 3.2: Implementar parsing y validaciÃ³n
FunciÃ³n para validar argumentos (nÃºmeros positivos, rangos vÃ¡lidos)
ConversiÃ³n de strings a enteros
Manejo de errores bÃ¡sicos

Paso 3.3: Implementar gestiÃ³n de tiempo
FunciÃ³n para obtener timestamp actual en milisegundos
FunciÃ³n para calcular diferencias de tiempo
FunciÃ³n de sleep precisa (mejor que usleep para tiempos pequeÃ±os)

Paso 3.4: Crear sistema de inicializaciÃ³n
Inicializar mutex para cada tenedor
Inicializar mutex para output
Crear e inicializar estructura de cada filÃ³sofo
Crear estructura global de simulaciÃ³n

Paso 3.5: Implementar rutina bÃ¡sica del filÃ³sofo
Estado inicial: thinking
Bucle principal con las acciones
FunciÃ³n para cada acciÃ³n (eat, sleep, think)
Sistema de logs con timestamp

Paso 3.6: Implementar toma de tenedores
Estrategia para evitar deadlock (orden especÃ­fico de toma)
Lock/unlock de mutex de tenedores
Manejo del caso especial (un solo filÃ³sofo)

Paso 3.7: Crear monitor de muerte
Hilo separado que vigila constantemente
Verificar tiempo desde Ãºltima comida
DetecciÃ³n de condiciÃ³n de parada por comidas completas
Sistema de flags para terminar simulaciÃ³n

Paso 3.8: Implementar limpieza y finalizaciÃ³n
Join de todos los hilos
DestrucciÃ³n de todos los mutex
LiberaciÃ³n de memoria dinÃ¡mica
CÃ³digos de retorno apropiados



FASE 4: OPTIMIZACIÃ“N Y DEBUGGING ðŸ”§

Paso 4.1: Prevenir deadlocks
Implementar orden especÃ­fico para tomar tenedores
Considerar caso par/impar para filÃ³sofos
Testear con diferentes nÃºmeros de filÃ³sofos

Paso 4.2: Optimizar precisiÃ³n temporal
Minimizar tiempo entre checks de muerte
Optimizar funciones de tiempo
Asegurar logs precisos (mÃ¡ximo 10ms de delay)

Paso 4.3: Manejo de race conditions
Proteger todas las variables compartidas
Minimizar tiempo en secciones crÃ­ticas
Verificar atomicidad de operaciones




FASE 5: TESTING COMPREHENSIVO ðŸ§ª
Paso 5.1: Tests bÃ¡sicos
Un filÃ³sofo (debe morir)
Casos edge: nÃºmeros muy grandes/pequeÃ±os
Argumentos invÃ¡lidos

Paso 5.2: Tests de concurrencia
Diferentes nÃºmeros de filÃ³sofos (2, 3, 4, 5, 100, 200)
Diferentes combinaciones de tiempos
Tests de larga duraciÃ³n

Paso 5.3: Tests de precisiÃ³n
Verificar timestamps exactos
Comprobar que no hay delays > 10ms en muerte
Validar orden correcto de logs



CONSIDERACIONES IMPORTANTES âš ï¸
Errores comunes a evitar:

Data races: No proteger variables compartidas
Deadlock: Orden incorrecto de toma de tenedores
Timing issues: Usar usleep para delays largos
Memory leaks: No liberar memoria o no destruir mutex
Logs mezclados: No proteger la salida estÃ¡ndar
Estrategias clave:
Orden de tenedores: Los filÃ³sofos pares primero derecha, impares primero izquierda
Monitor separado: Hilo dedicado solo a verificar muerte/parada
Timestamps precisos: Calcular desde inicio de simulaciÃ³n
Exit conditions: Flags atÃ³micos para terminar limpiamente


ESTRUCTURA DE ARCHIVOS RECOMENDADA ðŸ“

philo/
â”œâ”€â”€ Makefile
â”œâ”€â”€ philosopher.h
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.c -- Punto de entrada, verificar numero de argumentos, orquestacion general, manejo de errores, flujo principal (crear hilos...)
â”‚   â”œâ”€â”€ init.c -- Crear mutex para cada tenedor y para output, iniciar filosofos (array de filosofos con sus datos), asignacion de tenedores 
				  (cada filosofo con sus tenedores izquierdo/derecho), establecer tiempos de inicios de estados iniciales, verificar inicializaciones
â”‚   â”œâ”€â”€ parsing.c -- Validacion de argumentos (numeros validos y positivos), convertir strings a ints, validar rangos (por ejemplo time_to_die > 0)
					 manejos de errores con mensajes especificos, parsing del argumento opcional: number_of_times_each_philosopher_must_eat
â”‚   â”œâ”€â”€ philosopher.c -- rutina del filosofo (funcion q ejecutara cada hilo), estado del filosofo (comer, dormir, pensar), toma de tenedores (logica para evitar deadlock)
						 liberacion de tenedores (dejar tenedores disponibles despues de comer), logging de acciones (imprimir estados con timestamp protegido por mutex)
â”‚   â”œâ”€â”€ monitor.c -- monitor de muerte (hilo q verifica constantemente si algun filosofo murio), verificacion de tiempos (comprobar time_to_die desde ultima comida), 
					 condicion de parada (verificar si todos comieron el numero requerido de veces), flags de finalizacion (establecer seÃ±ales para q otros hilos terminen), deteccion precisa (deteccion en menos de 10m)
â”‚   â”œâ”€â”€ time.c -- obtener timestamp (obtener tiempo actual en milisegundos), calcular diferencias (calcular tiempo transcurrido), sleep preciso (implementar delay mas preciso q usleep para tiempos pequeÃ±os)
				  tiempo de inicio (establecer y mantener referencia del tiempo inicial), utilidades temporales (funciones auxiliares de manejo de tiempo)
â”‚   â””â”€â”€ utils.c -- Funciones de limpieza (destruir mutex, liberal memoria, join de hilos), funciones auxiliares, utilidades de string