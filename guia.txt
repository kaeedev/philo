🎯 GUÍA COMPLETA: PROYECTO PHILOSOPHERS

FASE 1: COMPRENSIÓN Y PLANIFICACIÓN 📚

Paso 1.1: Entender el problema conceptual
El problema clásico: Los filósofos representan procesos que compiten por recursos compartidos (tenedores)
El deadlock: Situación donde todos los filósofos toman su tenedor izquierdo simultáneamente y ninguno puede tomar el derecho
Race conditions: Cuando múltiples hilos acceden a datos compartidos sin sincronización
Starvation: Cuando un filósofo nunca consigue ambos tenedores

Paso 1.2: Identificar los componentes principales
Filósofos (hilos/threads)
Tenedores (recursos compartidos protegidos por mutex)
Estados: thinking, eating, sleeping, died
Tiempo: timestamps, timeouts, duración de acciones
Sincronización: mutex para tenedores y para output



FASE 2: DISEÑO DE LA ARQUITECTURA 🏗️

Paso 2.1: Definir las estructuras de datos
Piensa en qué información necesitas almacenar para:
Cada filósofo: id, estado, último tiempo de comida, número de comidas
Simulación global: número de filósofos, tiempos, condiciones de parada
Tenedores: uno por filósofo con su mutex correspondiente
Sincronización: mutex para imprimir, variables de control

Paso 2.2: Planificar el flujo del programa
Inicialización: parsing de argumentos, creación de estructuras, inicialización de mutex
Creación de hilos: un hilo por filósofo
Rutina del filósofo: bucle infinito con las acciones
Monitor: hilo que vigila la muerte y condiciones de parada
Limpieza: join de hilos, destrucción de mutex, liberación de memoria



FASE 3: IMPLEMENTACIÓN PASO A PASO 💻

Paso 3.1: Configurar el entorno básico
Crear el header con todas las includes necesarias
Definir las estructuras principales
Configurar el Makefile correctamente
Crear los archivos fuente básicos

Paso 3.2: Implementar parsing y validación
Función para validar argumentos (números positivos, rangos válidos)
Conversión de strings a enteros
Manejo de errores básicos

Paso 3.3: Implementar gestión de tiempo
Función para obtener timestamp actual en milisegundos
Función para calcular diferencias de tiempo
Función de sleep precisa (mejor que usleep para tiempos pequeños)

Paso 3.4: Crear sistema de inicialización
Inicializar mutex para cada tenedor
Inicializar mutex para output
Crear e inicializar estructura de cada filósofo
Crear estructura global de simulación

Paso 3.5: Implementar rutina básica del filósofo
Estado inicial: thinking
Bucle principal con las acciones
Función para cada acción (eat, sleep, think)
Sistema de logs con timestamp

Paso 3.6: Implementar toma de tenedores
Estrategia para evitar deadlock (orden específico de toma)
Lock/unlock de mutex de tenedores
Manejo del caso especial (un solo filósofo)

Paso 3.7: Crear monitor de muerte
Hilo separado que vigila constantemente
Verificar tiempo desde última comida
Detección de condición de parada por comidas completas
Sistema de flags para terminar simulación

Paso 3.8: Implementar limpieza y finalización
Join de todos los hilos
Destrucción de todos los mutex
Liberación de memoria dinámica
Códigos de retorno apropiados



FASE 4: OPTIMIZACIÓN Y DEBUGGING 🔧

Paso 4.1: Prevenir deadlocks
Implementar orden específico para tomar tenedores
Considerar caso par/impar para filósofos
Testear con diferentes números de filósofos

Paso 4.2: Optimizar precisión temporal
Minimizar tiempo entre checks de muerte
Optimizar funciones de tiempo
Asegurar logs precisos (máximo 10ms de delay)

Paso 4.3: Manejo de race conditions
Proteger todas las variables compartidas
Minimizar tiempo en secciones críticas
Verificar atomicidad de operaciones




FASE 5: TESTING COMPREHENSIVO 🧪
Paso 5.1: Tests básicos
Un filósofo (debe morir)
Casos edge: números muy grandes/pequeños
Argumentos inválidos

Paso 5.2: Tests de concurrencia
Diferentes números de filósofos (2, 3, 4, 5, 100, 200)
Diferentes combinaciones de tiempos
Tests de larga duración

Paso 5.3: Tests de precisión
Verificar timestamps exactos
Comprobar que no hay delays > 10ms en muerte
Validar orden correcto de logs



CONSIDERACIONES IMPORTANTES ⚠️
Errores comunes a evitar:

Data races: No proteger variables compartidas
Deadlock: Orden incorrecto de toma de tenedores
Timing issues: Usar usleep para delays largos
Memory leaks: No liberar memoria o no destruir mutex
Logs mezclados: No proteger la salida estándar
Estrategias clave:
Orden de tenedores: Los filósofos pares primero derecha, impares primero izquierda
Monitor separado: Hilo dedicado solo a verificar muerte/parada
Timestamps precisos: Calcular desde inicio de simulación
Exit conditions: Flags atómicos para terminar limpiamente


ESTRUCTURA DE ARCHIVOS RECOMENDADA 📁

philo/
├── Makefile
├── philosopher.h
├── src/
│   ├── main.c -- Punto de entrada, verificar numero de argumentos, orquestacion general, manejo de errores, flujo principal (crear hilos...)
│   ├── init.c -- Crear mutex para cada tenedor y para output, iniciar filosofos (array de filosofos con sus datos), asignacion de tenedores 
				  (cada filosofo con sus tenedores izquierdo/derecho), establecer tiempos de inicios de estados iniciales, verificar inicializaciones
│   ├── parsing.c -- Validacion de argumentos (numeros validos y positivos), convertir strings a ints, validar rangos (por ejemplo time_to_die > 0)
					 manejos de errores con mensajes especificos, parsing del argumento opcional: number_of_times_each_philosopher_must_eat
│   ├── philosopher.c -- rutina del filosofo (funcion q ejecutara cada hilo), estado del filosofo (comer, dormir, pensar), toma de tenedores (logica para evitar deadlock)
						 liberacion de tenedores (dejar tenedores disponibles despues de comer), logging de acciones (imprimir estados con timestamp protegido por mutex)
│   ├── monitor.c -- monitor de muerte (hilo q verifica constantemente si algun filosofo murio), verificacion de tiempos (comprobar time_to_die desde ultima comida), 
					 condicion de parada (verificar si todos comieron el numero requerido de veces), flags de finalizacion (establecer señales para q otros hilos terminen), deteccion precisa (deteccion en menos de 10m)
│   ├── time.c -- obtener timestamp (obtener tiempo actual en milisegundos), calcular diferencias (calcular tiempo transcurrido), sleep preciso (implementar delay mas preciso q usleep para tiempos pequeños)
				  tiempo de inicio (establecer y mantener referencia del tiempo inicial), utilidades temporales (funciones auxiliares de manejo de tiempo)
│   └── utils.c -- Funciones de limpieza (destruir mutex, liberal memoria, join de hilos), funciones auxiliares, utilidades de string